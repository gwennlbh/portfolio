---
import type { GetStaticPaths } from "astro";
import { getCollection, getEntry } from "astro:content";
import StrongHeader from "../../components/StrongHeader.astro";
import TagReference from "../../components/TagReference.astro";
import Layout from "../../layouts/Regular.astro";
import BlockLink from "./_components/BlockLink.astro";
import BlockMedia from "./_components/BlockMedia.astro";
import BlockParagraph from "./_components/BlockParagraph.astro";
import { imageAttrs } from "./media";
import { differenceInYears } from "date-fns";

export const getStaticPaths = (async () => {
  return await getCollection("works").then((works) =>
    works
      .flatMap(({ id, data: { metadata } }) => [
        id,
        ...(metadata.aliases ?? []),
      ])
      .map((id) => ({ params: { work: id } })),
  );
}) satisfies GetStaticPaths;

// lone row: the cell is the only one of its kind in all of the rows it's in
const isLoneRow = (cell: string, layout: string[][]) =>
  layout.some((row) => row.every((c) => c === cell)) &&
  !layout.some((row) => row.includes(cell) && !row.every((c) => c === cell));

const hasMediaRowBefore = (
  cell: string,
  layout: string[][],
  blocks: { id: string; type: string }[],
) =>
  layout
    // keep all rows up to the current one
    .slice(
      0,
      layout.findIndex((row) => row.includes(cell)),
    )
    // search for a media-type block in the row's cells
    .some((row) =>
      row.some((cell) => blocks.find((b) => b.id === cell)?.type === "media"),
    );

const entry = await getEntry("works", Astro.params.work!.toString());
if (!entry) return Astro.rewrite("/404");

const {
  id,
  metadata,
  metadata: { tags, wip, colors, started, finished, additionalMetadata: misc },
} = entry.data;

const startYear = started?.getFullYear();
const endYear = finished?.getFullYear();
const year =
  started && !finished && !wip
    ? // Still active
      `${startYear}～now`
    : started &&
        finished &&
        differenceInYears(finished, started) > 1 &&
        startYear !== endYear
      ? // Was done over multiple years
        `${startYear}～${endYear}`
      : // Done within a single year
        (endYear ?? startYear);

const titleStyle = misc?.title_style ?? "";

const content = Object.keys(entry.data.content).includes("default")
  ? { fr: entry.data.content.default, en: entry.data.content.default }
  : entry.data.content;

let madeWith = await Promise.all(
  metadata.madeWith?.map((tech) => getEntry("technologies", tech.id)) ??
    metadata.additionalMetadata?.made_with?.map((tech) =>
      getEntry("technologies", tech),
    ) ??
    [],
).then((techs) => techs.filter((x) => !!x));

const { blocks, layout, footnotes } =
  Object.entries(content).find(([lang]) => lang === Astro.locals.lang)?.[1] ??
  Object.values(content)[0];

const layoutWidth = Math.max(...layout.map((row) => new Set(row).size));

/**
 * Screen width below which the layout switches to a single column.
 * Depends on how wide the layout is, since the goal is to prevent ridiculously small images.
 * This equation was derived from the following constraints:
 * - 500 = m * 2 + p (cutoff at 500px for 2-cell wide layouts)
 * - 700 = m * 3 + p (cutoff at 700px for 3-cell wide layouts)
 */
const portraitModeCutoff = 200 * layoutWidth + 100;

const cssGridAreas = layout
  .map((row) => '"' + row.map((cell) => `_${cell}`).join(" ") + '"')
  .join(" ");

const firstMediaBlock = blocks.find((b) => b.type === "media");

const folderPath = entry.data.source.split("\\").slice(0, -2).join("\\");
---

<Layout colors={colors}>
  <StrongHeader
    back="/"
    editButton={entry.data.source}
    editFolderButton={folderPath}
    title={titleStyle === "image" && firstMediaBlock
      ? { img: imageAttrs(firstMediaBlock) }
      : {
          fr: content.fr?.title || content.default?.title || id,
          en: content.en?.title || content.default?.title || id,
        }}
    wip={wip}
  >
    <section class="tags">
      <ul>
        {year && <li class="year">{year}</li>}
        {tags?.map((tag) => <TagReference tag={tag} />)}
      </ul>
    </section>
  </StrongHeader>

  <main>
    {
      (
        <section style={`grid-template-areas: ${cssGridAreas}; `}>
          {blocks
            .filter((b) =>
              titleStyle === "image" ? b.id !== firstMediaBlock?.id : true,
            )
            .map((block) => (
              <div
                id={block.anchor || undefined}
                class={`block ${isLoneRow(block.id, layout) && hasMediaRowBefore(block.id, layout, blocks) ? "indent" : ""}`}
                data-type={block.type}
                data-block-id={block.id}
                style={`grid-area: _${block.id}`}
              >
                {block.type === "paragraph" && <BlockParagraph {...block} />}
                {block.type === "link" && <BlockLink {...block} />}
                {block.type === "media" && <BlockMedia {...block} />}
              </div>
            ))}
        </section>
      )
    }
  </main>

  {
    madeWith && madeWith.length > 0 && (
      <section class="made-with">
        <h2 i18n>made with</h2>
        <ul class="technologies">
          {madeWith.map(({ id, data: { name } }) => (
            <li>
              <a href={`/using/${id}`}>{name === "C Sharp" ? "C#" : name}</a>
            </li>
          ))}
        </ul>
      </section>
    )
  }

  {
    Object.keys(footnotes).length ? (
      <section class="footnotes">
        <h2 i18n>footnotes</h2>
        <ul>
          {Object.entries(footnotes).map(([id, content]) => (
            <li id={`fn:${id}`}>
              <code>{id}. </code>
              <span
                set:html={content.replace(/^<p>/, "").replace(/<\/p>$/, "")}
              />
            </li>
          ))}
        </ul>
      </section>
    ) : null
  }

  <div class="swatches" slot="technical-pre">
    {
      Object.entries(colors ?? {}).map(([name, color], i) => (
        <code
          class="swatch"
          style={`background-color: ${color}; color: var(--${name === "primary" ? "secondary" : "primary"}, black)`}
          onclick={`navigator.clipboard.writeText(JSON.stringify('${color}'))`}
        >
          {["⊓", "⊔", "⊐"][i]}
        </code>
      ))
    }
  </div>
</Layout>

<Fragment
  set:html={`<style>@media (min-width: ${portraitModeCutoff}px) {
    main > section {
      display: ${cssGridAreas ? "grid" : "block"} !important;
    }

    .block[data-type="media"] :global(img, video) {
      object-position: left;
      /* max-height: 60vh; */
    }

    .block[data-type="paragraph"].indent {
      margin-left: 2em;
    }

    .block {
      min-height: 0;
      min-width: 0;
    }
  }</style>`}
/>

<style>
  .tags ul {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5em 1em;
  }

  .year {
    list-style: none;
  }

  .tags .year::before {
    display: none;
  }

  .tags .year::after {
    content: "";
    display: inline-block;
    margin-bottom: 0.5ch;
    margin-left: 0.5em;
    height: 3px;
    width: 6ch;
    background-color: color-mix(in lab, var(--primary), transparent 40%);
  }

  main > section {
    display: flex;
    flex-direction: column;
    gap: 2em;
    max-width: 80rem;
  }

  @media (min-width: 800px) {
    main > section {
      margin-right: 7rem;
    }
  }

  section.made-with h2 {
    font-size: 2.8em;
  }
  section.made-with {
    font-size: 1.7rem;
  }
  section.made-with ul {
    margin-top: 1em;
    display: flex;
    flex-direction: column;
    gap: 0.5em;
  }

  section.footnotes {
    font-size: 1.7rem;
  }

  section.footnotes h2 {
    margin-bottom: 0.5em;
  }

  pre,
  code {
    font-family:
      Martian Mono,
      monospace;
  }

  section.metadata pre {
    opacity: 0.5;
  }

  .block[data-type="paragraph"] :global(li) {
    margin-bottom: 0.5em;
  }
  .block[data-type="paragraph"] :global(a:hover, a:focus-visible) {
    /* Otherwise it breaks text flow on hover/focus */
    font-weight: normal;
  }

  .block[data-type="paragraph"] :global(blockquote) {
    margin: 0.5em 0;
    padding-left: 1em;
    border-left: 4px solid color-mix(in srgb, var(--primary) 50%, transparent);
    opacity: 0.8;
  }

  .swatches {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5em;
  }

  .swatches .swatch {
    padding: 0.5em 1em;
    transition: transform 0.125s ease;
  }
</style>
